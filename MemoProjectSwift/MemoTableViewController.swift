//
//  MemoTableViewController.swift
//  MemoProjectSwift
//
//  Created by Lexi Francis on 4/20/24.
//

import UIKit
import CoreData

class MemoTableViewController: UITableViewController {
    
    var Memos:[NSManagedObject] = [] //  changes the contacts array to hold NSManagedObject instances. This allows us to hold the Contact objects that will be retrieved from CoreData.
    let appDelegate = UIApplication.shared.delegate as! AppDelegate
    
    override func viewDidLoad() {
        super.viewDidLoad()
        self.navigationItem.leftBarButtonItem = self.editButtonItem
        
        // This will put a button with the word Edit in the left part of the navigation bar.
        
        loadDataFromDatabase()
    }
    
    override func viewWillAppear(_ animated: Bool) {
        
        // This ensures that the data is reloaded from the database in line 2. Line 3 reloads the data in the table itself.
        
        loadDataFromDatabase()
        tableView.reloadData()
    }

  func loadDataFromDatabase() {
      
      // The code starts by reading from the default settings
      
        let settings = UserDefaults.standard
        let sortField = settings.string(forKey: Constants.kSortField) // retrieves the sort field and sort direction using the keys defined in Constants.swift.
      
      
        let sortAscending = settings.bool(forKey: Constants.kSortDirectionAscending)
        //Set up Core Data Context
        let context = appDelegate.persistentContainer.viewContext
        //Set up Request
        let request = NSFetchRequest<NSManagedObject>(entityName: "Memo")
        //Specify sorting
        let sortDescriptor = NSSortDescriptor(key: sortField, ascending: sortAscending)
      
      // NSSortDescriptor is a class that contains instructions on how to order objects. By passing in the sort field and whether to sort in ascending or descending order, the fetch request will use these instructions to do the actual sorting.
      
        let sortDescriptorArray = [sortDescriptor]
        //to sort by multiple fields, add more sort descriptors to the array
        request.sortDescriptors = sortDescriptorArray
        do {
            Memos = try context.fetch(request)
        } catch let error as NSError {
            print("Could not fetch. \(error), \(error.userInfo)")
        }
   }


    // MARK: - Table view data source

    override func numberOfSections(in tableView: UITableView) -> Int {
        return 1 // changed this to 1 to make the number of sections appear
        
        // To have the data actually show up in the table, you modify some of the autogenerated methods. Locate the numberOfSections(in tableView:) method. This method returns the number of sections (or groupings) in a table. For this table, there’s a single section making it very simple to implement.
        
        
    }

    override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        return Memos.count // returns the number of elements in the contacts array.
        
        // Just below is the tableView(_ tableView:numberOfRowsInSection:) method. This returns the number of data rows a particular section has, so that iOS knows how many table cells to present. For now, the number of rows will equal how many names are in the array given previously. (Later, it will return how many Contact objects are in the database.)
        
        // The tableView(_ tableView:cellForRowAt indexPath:) method is the workhorse method when it comes to tables.
        
        
    }
        // Load memos from a data source
                memo = MemoDataSource.shared.loadMemos() // Implement MemoDataSource
                
                // Uncomment the following line to display an Edit button in the navigation bar for this view controller.
                // self.navigationItem.rightBarButtonItem = self.editButtonItem
            }
            
            // MARK: - Table view data source
        
    override func numberOfSections(in tableView: UITableView) -> Int {
            return 1 // Assuming one section for all memos
        }
    override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
            return memos.count
        }
    override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
            let cell = tableView.dequeueReusableCell(withIdentifier: "MemoCell", for: indexPath)
            
            let memo = Memos[indexPath.row]
            cell.textLabel?.text = memo.title
            cell.detailTextLabel?.text = memo.content
            
            return cell
        }
    // Override to support conditional editing of the table view.
        override func tableView(_ tableView: UITableView, canEditRowAt indexPath: IndexPath) -> Bool {
            return true
        }
    // Override to support editing the table view.
        override func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCell.EditingStyle, forRowAt indexPath: IndexPath) {
            if editingStyle == .delete {
                // Delete the memo from the data source
                           memos.remove(at: indexPath.row)
                           // Update the table view
                           tableView.deleteRows(at: [indexPath], with: .fade)
                       }
                   }
    //work on navigation
        
        
        
        
  
>>>>>>> c895e91425d21ce1adbde0bf39baaba3332bee65

   
    override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        let cell = tableView.dequeueReusableCell(withIdentifier: "MemosCell", for: indexPath)
        
        // creates the cell object. The only thing you need to change in this line is the identifier, ContactsCell. This is a unique identifier for all cells in the table that are set up in the same way so the objects can be reused when the cell scrolls off the screen.
        
        // Retrieve the Contact object from the contacts array at the specified indexPath.row
                let Memo = Memo[indexPath.row] as? Memo
                
         
                let mainLabelText = "\(Memo?.memo ?? "") from  \(Memo?.city ?? "")" // backslash is used for string interpolation.
                cell.textLabel?.text = mainLabelText
        
        // textLabel property of the cell to set the text that will show up on screen. The data is pulled from the contacts array using the requested row number as the index.
                
                if let birthday = contact?.birthday {
                    let formatter = DateFormatter()
                    formatter.dateStyle = .medium
                    let detailLabelText = "Born on: \(formatter.string(from: birthday))"
                    cell.detailTextLabel?.text = detailLabelText
                } else {
                    cell.detailTextLabel?.text = ""
                }
                
                cell.accessoryType = .detailDisclosureButton
                return cell
            }

        
        /*let cell = tableView.dequeueReusableCell(withIdentifier: "ContactsCell", for: indexPath)
        
        // Configure the cell...
        let contact = contacts[indexPath.row] as? Contact
        cell.textLabel?.text = contact?.contactName
        cell.detailTextLabel?.text = contact?.city
        cell.accessoryType = .detailDisclosureButton
        return cell
    }*/
    override func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        let selectedContact = contacts[indexPath.row] as? Contact
        
        // getting the contact object associated with the selected row
        
        let name = selectedContact!.contactName!
        let email = selectedContact!.email!
        
        let actionHandler = { (action:UIAlertAction!) -> Void in
            let storyboard = UIStoryboard(name: "Main", bundle: nil) // gets a reference to the storyboard named Main, as there may be more than one storyboard in a project. Note that the name is a string, so you have to be careful with spelling as the compiler can’t check it for you.
            
            
            let controller = storyboard.instantiateViewController(withIdentifier: "ContactController")// instantiates an instance of the view controller using an identifier. This also needs to be entered into the storyboard, which you will do shortly. The controller is cast as a ContactsViewcontroller, because you need to set the selected contact,
                as? MemoViewController
            controller?.currentMemo = selectedMemo
            self.navigationController?.pushViewController(controller!, animated: true)
            
                // uses the navigation controller to push the view controller onto the navigation stack. This ensures that the controller has the Back button to allow the user to go back to the table view controller.
        }
        
        let alertController = UIAlertController(title: "Contact selected",
                                                    message:  "Name: \(name)\nEmail: \(email)",
                preferredStyle: .alert)
        // UIAlertController with a title and message. The preferred style can either be .alert (which we are using) or .actionsheet. The action sheet is used when more than two or three options are needed, as it stacks the buttons on top of each other.
        
        let actionCancel = UIAlertAction(title: "Cancel",
                                         style: .cancel,
                                         handler: nil) // add the two buttons to the Alert Controller, and line 20 displays the controller.
        let actionDetails = UIAlertAction(title: "Show Details",
                                          style: .default,
                                          handler: actionHandler)
        alertController.addAction(actionCancel)
        alertController.addAction(actionDetails)
        present(alertController, animated: true, completion: nil)
    }

    /*
    // Override to support conditional editing of the table view.
    override func tableView(_ tableView: UITableView, canEditRowAt indexPath: IndexPath) -> Bool {
        // Return false if you do not want the specified item to be editable.
        return true
    }
    */

    override func tableView(_ tableView: UITableView,
                            commit editingStyle: UITableViewCell.EditingStyle,
                            forRowAt indexPath: IndexPath) {
        if editingStyle == .delete {
            // Delete the row from the data source
            let contact = contacts[indexPath.row] as? Contact
            let context = appDelegate.persistentContainer.viewContext
            context.delete(contact!)
            do {
                try context.save()
                
                // Saving the context (line 10) can cause errors, so this is surrounded by try/catch. Forcing the context to save changes causes the object to be deleted from the data store immediately.
            }
            catch  {
                fatalError("Error saving context: \(error)")
            }
            
            loadDataFromDatabase() // reloads the data from the database into the contacts array.
            
            tableView.deleteRows(at: [indexPath], with: .fade) // removes the row from the table. In this case, it is done with an animation. You can option-click the method name to see more options for fading the row out.
        } else if editingStyle == .insert {
            // Create a new instance of the appropriate class, insert it into the array,
            //and add a new row to the table view
        }
    }
